# -*- coding: utf-8 -*-
"""Hahn Forth MPCR OISC 2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QKPn2R2JLtEvymV-10ETUBlsAU-Q0gvv

# MPCR OISC
"""

# Thing <- Name of the thing <- Name of the Name of the thing

# ..... <- 5 <- Five

import numpy as np
import matplotlib.pyplot as plt

N = 4096


def load_from_string(content):

    content += '''PS'''

    lines = [line.split('#')[0].strip() for line in content.split("\n") if line.split('#')[0]]

    C = np.zeros(N, dtype='object')
    D = {}
    i = 0
    for line in lines:

        tokens = line.strip().replace(',', ' ').split()
        D[tokens[0]] = i
        code = [D[token] if token in D else int(token) for token in tokens[1:]]

        if code:
            C[i] = i + 1
            C[i+1:i+1+len(code)] = code
            i += len(code) + 1
        else:
            i += 1

    return C, D

code_ai = """
IP    # Instruction Pointer
A     # ALU Operand Register
B     # ALU Operand Register
C     # AUX Register
X     # AUX Register
Y     # AUX Register
Z     # AUX Register
I     # Loop Index
J     # Loop Index
K     # Loop Index
Add
Sub
Mult
Div
Equal
Greater
Lesser
L
S
W
P
Halt 0,L L,0
Push A,S W,0
Peek S,A A,S W,0
Pop S,A W,0
Drop S,C W,0
Dup S,A A,S A,S W,0
Swap S,B S,A B,S A,S W,0
Zero 0,L L,S W,0
One 1,L L,S W,0
+ S,B S,A Add,S W,0
- S,B S,A Sub,S W,0
* S,B S,A Mult,S W,0
/ S,B S,A Div,S W,0
Not S,A -1,L L,B Mult,A 1,L L,B Add,S W,0
Negate S,A -1,L L,B Mult,S W,0
Rot S,C S,B S,A C,S A,S B,S W,0
Continue A,A W,0
Branch Dup,W Not,W Rot,W *,W Rot,W *,W +,W S,A A,W W,0
If Continue,S Rot,W Branch,W W,0
Square Dup,W *,W W,0
Cube Dup,W Square,W *,W W,0
Fourth Square,W Square,W A,A W,0
Double Dup,W +,W W,0
-- S,A 1,L L,B Sub,S W,0
++ S,A 1,L L,B Add,S W,0
== S,B S,A Equal,S W,0
> S,B S,A Greater,S W,0
< S,B S,A Lesser,S W,0
!= ==,W Not,W W,0
Word1 Double,W W,0
Apple 0
Orange 0
! S,A S,P W,0
@ S,A P,S W,0
Halve S,A 2,L L,B Div,S W,0
Over S,B S,A A,S B,S A,S W,0
Mod S,Y S,X X,A Y,B Div,A Mult,B X,A Sub,S W,0
I-- I,S --,W S,I W,0
I++ I,S ++,W S,I W,0
I--Y0 I,S --,W S,I Y,0 W,0
Loop S,I I--,W S,X IP,Y X,W Continue,S I--Y0,S I,S One,W >,W Branch,W W,0
SL 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
WL 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
Text 3 97 98 99 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
"""

C, D = load_from_string(code_ai) # Codes, Dictionary

# #Decompiler
# D2 = {v: k for k, v in D.items()}  # invert D
# print(f"{'Index':<8}{'Name':<16}{'Code':<16}{'Decode':<16}")
# for i in range(len(C) - 2000):  # Just showing the first 3 rows as an example
#     value_name = D2.get(C[i], '')  # Check if the value has a corresponding name in D2
#     if i in D2:
#         print(f"{i:<8}{D2[i]:<16}{C[i]:<16}{value_name:<16}")
#     else:
#         print(f"{i:<8}{'':<16}{C[i]:<16}{value_name:<16}")

def is_integer(x):
    return x.lstrip('-').isdigit()

def value(token):
    return int(token) if is_integer(token) else D[token]

def compile_program(X):
    program = []
    tokens = X.split(' ')
    for token in tokens:
        if is_integer(token):
            program += [int(token), D['L'], D['L'], D['S']]
        elif ',' in token:
            a, b = token.split(',')
            program += [value(a), value(b)]
        else:
            program += [D[token], D['W']]    # Call Word
    program += [0, D['L'], D['L'], D['IP']]  # Halt
    return program



def setup(program):
    program = compile_program(program)
    M = np.zeros(N, dtype=int)
    M[:len(C)] = C
    M[D["PS"]:D["PS"] + len(program)] = program
    M[D["IP"]] = D["PS"]
    M[D["SL"]] = 0
    M[D["WL"]] = 0
    return M


def run(M):

    IP, A, B, C, Add, Sub, Mult, Div, L, P, S, SL, W, WL, Equal, Greater, Lesser = (D[x] for x in ["IP", "A", "B", "C", "Add", "Sub", "Mult", "Div", "L", "P", "S", "SL", "W", "WL", "Equal", "Greater", "Lesser"])

    while M[IP] > 0:

        M[IP] += 2

        a,b = M[IP]-2 , M[IP]-1  # a is pointer to address i, b is pointer to address j
        i,j = M[a]    , M[b]     # copy from address i, paste in address j

        if j == L:
            M[L] = i
        elif i in [S, W]:
            if i == S:
                M[j] = M[SL + M[SL]]
                M[SL] -= 1
            else:
                M[j] = M[WL + M[WL]]
                M[WL] -= 1
        elif j in [S, W]:
            if j == S:
                M[SL] += 1
                M[SL + M[SL]] = M[i]
            else:
                M[WL] += 1
                M[WL + M[WL]] = M[0]
                M[0] = M[i]
        elif i == P:
            M[j] = M[M[A]]
        elif j == P:
            M[M[A]] = M[i]
        else:
            M[j] = M[i]


        #Memory Mapped ALU
        M[Add]  = M[A] + M[B]
        M[Sub]  = M[A] - M[B]
        M[Mult] = M[A] * M[B]
        M[Div]  = 0 if M[B] == 0 else M[A] // M[B]

        M[Equal]   = M[A] == M[B]
        M[Greater] = M[A] > M[B]
        M[Lesser]  = M[A] < M[B]


    return M

# Test data
def check():
    assert np.array_equal(answer, np.array(expected_answer)), f'Test {program} failed. Expected {expected_answer}, but got {answer.tolist()}.'

test_programs = [
    ("10 11 +", [21]),                                     # Add 10 and 11
    ("10 3 -", [7]),                                       # Subtract 3 from 10
    ("8 9 *", [72]),                                       # Multiply 8 by 9
    ("10 2 /", [5]),                                       # Divide 10 by 2
    ("10 3 >", [1]),                                       # Check if 10 is greater than 3
    ("3 5 >", [0]),                                        # Check if 3 is greater than 5
    ("1 Not", [0]),                                        # Logical NOT of 1
    ("5 Fourth", [625]),                                   # Raise 5 to the power of 4
    ("8 9 * 7 + Fourth", [38950081]),                      # Multiply 8 and 9, add 7, and raise the result to the power of 4
    ("0 Not", [1]),                                        # Logical NOT of 0
    ("-5 Negate", [5]),                                    # Negate -5
    ("6 --", [5]),                                         # Decrement 6 by 1
    ("3 Double", [6]),                                     # Double the value 3
    ("3 5 -", [-2]),                                       # Subtract 5 from 3
    ("3 5 >", [0]),                                        # Check if 3 is greater than 5
    ("0 5 >", [0]),                                        # Check if 0 is greater than 5
    ("6 5 >", [1]),                                        # Check if 6 is greater than 5
    ("5 Double,S Fourth,S One Branch", [625]),             # Double 5, raise it to the power of 4, and branch based on 1 (true)
    ("5 Double,S Fourth,S Zero Branch", [10]),             # Double 5, raise it to the power of 4, and branch based on 0 (false)
    ("5 Continue,S Fourth,S One Branch 22 1 +", [625,23]), # Continue with operations, raise 5 to the power of 4, branch based on 1, add 22 and 1
    ("4 Halve", [2]),                                      # Divide 4 by 2
    ('2 4 + 3 -', [3]),                                    # Simple arithmetic
    ('2 2 2 2 2 + + + +', [10]),                           # Stacking operations
    ('5 2 * 10 /', [1]),                                   # Multiplication followed by division
    ('5 2 <', [0]),                                        # Lesser than check
    ('2 5 <', [1]),                                        # Lesser than check
    ('5 5 ==', [1]),                                       # Equality check
    ('5 3 !=', [1]),                                       # Non-equality check
    ('5 3 > 4 +', [5]),                                    # Greater than check with subsequent addition
    ('6 3 / 2 *', [4]),                                    # Division followed by multiplication
    ('2 5 > 3 4 + +', [7]),                                # Greater than check with subsequent operations
    ("10 3 Over", [10, 3, 10]),
    ("3 Cube", [27]),
    ("10 3 6 Rot", [6, 10, 3]),
    ("7 4 Mod", [3]),
    ("10 3 Mod", [1]),
    ("5 Continue,S Double,S One Branch", [10]),
    ("5 Double,S One If", [10]),
    ("5 Double,S Zero If", [5]),
    ("2 Word1,S 10 Loop", [1024]),
    ("2 Word1,S 8 Loop", [256]),
    ("5 S,Apple 10 Drop,W Apple,S", [5]),
    ]

test_programs += [(f"{i}", [i]) for i in range(1000)]

for i, (program, expected_answer) in enumerate(test_programs):
    M = setup(program)
    M = run(M)
    answer = M[D['SL']+1:D['SL']+1+M[D['SL']]]
    check()

print('All tests passed.')









import numpy as np
import matplotlib.pyplot as plt

N = 4096  # Memory size

# Visualization function
def visualize_memory_over_time(memory_matrix):
    plt.figure(figsize=(10, 6))
    plt.imshow(memory_matrix, aspect='auto', cmap='gray', interpolation='none')
    plt.colorbar(label='Memory Value')
    plt.title('Memory Evolution Over Time')
    plt.xlabel('Memory Address')
    plt.ylabel('Time Step')
    plt.show()

# VM setup function with random initial state
def setup_random(program):
    program = compile_program(program)
    M = np.random.randint(low=-1000, high=1000, size=N)  # Initialize random memory
    M[:len(C)] = C
    M[D["PS"]:D["PS"] + len(program)] = program
    M[D["IP"]] = D["PS"]
    M[D["SL"]] = 0
    M[D["WL"]] = 0
    return M

# VM run function that tracks memory over time
def run_with_memory_tracking(M):
    IP, A, B, C, Add, Sub, Mult, Div, L, P, S, SL, W, WL, Equal, Greater, Lesser = (D[x] for x in ["IP", "A", "B", "C", "Add", "Sub", "Mult", "Div", "L", "P", "S", "SL", "W", "WL", "Equal", "Greater", "Lesser"])

    memory_over_time = []  # To store snapshots of memory

    while M[IP] > 0:
        # Record memory snapshot at each step
        memory_over_time.append(M.copy())

        # Increment instruction pointer
        M[IP] += 2

        # Fetch instructions from memory
        a, b = M[IP] - 2, M[IP] - 1
        i, j = M[a], M[b]

        if j == L:
            M[L] = i
        elif i in [S, W]:
            if i == S:
                M[j] = M[SL + M[SL]]
                M[SL] -= 1
            else:
                M[j] = M[WL + M[WL]]
                M[WL] -= 1
        elif j in [S, W]:
            if j == S:
                M[SL] += 1
                M[SL + M[SL]] = M[i]
            else:
                M[WL] += 1
                M[WL + M[WL]] = M[0]
                M[0] = M[i]
        elif i == P:
            M[j] = M[M[A]]
        elif j == P:
            M[M[A]] = M[i]
        else:
            M[j] = M[i]

        # Memory Mapped ALU Operations
        M[Add] = M[A] + M[B]
        M[Sub] = M[A] - M[B]
        M[Mult] = M[A] * M[B]
        M[Div] = 0 if M[B] == 0 else M[A] // M[B]

        M[Equal] = M[A] == M[B]
        M[Greater] = M[A] > M[B]
        M[Lesser] = M[A] < M[B]

    return np.array(memory_over_time)  # Return memory snapshots as a matrix

# Random initial memory and program execution
random_program = "10 5 + 3 * 8 -"  # Example program
M_random = setup_random(random_program)
memory_matrix_random = run_with_memory_tracking(M_random)

# Visualize the memory evolution over time
visualize_memory_over_time(memory_matrix_random[:,:1000])















import numpy as np

# Increase N to ensure enough memory
N = 8192  # Increase from 4096 to 8192

def load_from_string(content):
    content += '''PS'''
    lines = [line.split('#')[0].strip() for line in content.split("\n") if line.split('#')[0]]
    C = np.zeros(N, dtype='object')
    D = {}
    i = 0
    for line in lines:
        tokens = line.strip().replace(',', ' ').split()
        D[tokens[0]] = i
        code = [D[token] if token in D else int(token) for token in tokens[1:]]
        if code:
            C[i] = i + 1
            C[i+1:i+1+len(code)] = code
            i += len(code) + 1
        else:
            i += 1
    return C, D, i

code_ai = """
IP    # Instruction Pointer
A     # ALU Operand Register
B     # ALU Operand Register
C     # AUX Register
X     # AUX Register
Y     # AUX Register
Z     # AUX Register
I     # Loop Index
J     # Loop Index
K     # Loop Index
Add
Sub
Mult
Div
Equal
Greater
Lesser
L
S
W
P
Halt 0,L L,0
Push A,S W,0
Peek S,A A,S W,0
Pop S,A W,0
Drop S,C W,0
Dup S,A A,S A,S W,0
Swap S,B S,A B,S A,S W,0
Zero 0,L L,S W,0
One 1,L L,S W,0
+ S,B S,A Add,S W,0
- S,B S,A Sub,S W,0
* S,B S,A Mult,S W,0
/ S,B S,A Div,S W,0
Not S,A -1,L L,B Mult,A 1,L L,B Add,S W,0
Negate S,A -1,L L,B Mult,S W,0
Rot S,C S,B S,A C,S A,S B,S W,0
Continue A,A W,0
Branch Dup,W Not,W Rot,W *,W Rot,W *,W +,W S,A A,W W,0
If Continue,S Rot,W Branch,W W,0
Square Dup,W *,W W,0
Cube Dup,W Square,W *,W W,0
Fourth Square,W Square,W A,A W,0
Double Dup,W +,W W,0
-- S,A 1,L L,B Sub,S W,0
++ S,A 1,L L,B Add,S W,0
== S,B S,A Equal,S W,0
> S,B S,A Greater,S W,0
< S,B S,A Lesser,S W,0
!= ==,W Not,W W,0
Word1 Double,W W,0
Apple 0
Orange 0
! S,A S,P W,0
@ S,A P,S W,0
Halve S,A 2,L L,B Div,S W,0
Over S,B S,A A,S B,S A,S W,0
Mod S,Y S,X X,A Y,B Div,A Mult,B X,A Sub,S W,0
I-- I,S --,W S,I W,0
I++ I,S ++,W S,I W,0
I--Y0 I,S --,W S,I Y,0 W,0
Loop S,I I--,W S,X IP,Y X,W Continue,S I--Y0,S I,S One,W >,W Branch,W W,0
SL 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
WL 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
Text 3 97 98 99 0  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
PS
"""

C, D, memory_pointer = load_from_string(code_ai)  # Get memory_pointer from load_from_string

def is_integer(x):
    return x.lstrip('-').isdigit()

def value(token):
    return int(token) if is_integer(token) else D[token]

def compile_program(program, M, memory_pointer):
    # This function will be updated to use the compiler for Forth
    program_code, memory_pointer = compile_forth(program, M, memory_pointer)
    return program_code, memory_pointer

def setup(program):
    M = np.zeros(N, dtype=int)
    M[:len(C)] = C
    program_code, memory_pointer_updated = compile_program(program, M, memory_pointer)
    # Copy compiled program into M starting at D["PS"]
    M[D["PS"]:D["PS"] + len(program_code)] = program_code
    M[D["IP"]] = D["PS"]
    M[D["SL"]] = 0
    M[D["WL"]] = 0
    return M

def run(M):
    IP, A, B, C_reg, Add, Sub, Mult, Div, L, P, S, SL, W, WL, Equal, Greater, Lesser = (
        D[x] for x in ["IP", "A", "B", "C", "Add", "Sub", "Mult", "Div", "L", "P", "S", "SL", "W", "WL", "Equal", "Greater", "Lesser"])

    while M[IP] > 0:
        M[IP] += 2
        a, b = M[IP]-2, M[IP]-1  # a is pointer to address i, b is pointer to address j
        i, j = M[a], M[b]         # copy from address i, paste in address j

        if j == L:
            M[L] = i
        elif i in [S, W]:
            if i == S:
                M[j] = M[SL + M[SL]]
                M[SL] -= 1
            else:
                M[j] = M[WL + M[WL]]
                M[WL] -= 1
        elif j in [S, W]:
            if j == S:
                M[SL] += 1
                M[SL + M[SL]] = M[i]
            else:
                M[WL] += 1
                M[WL + M[WL]] = M[0]
                M[0] = M[i]
        elif i == P:
            M[j] = M[M[A]]
        elif j == P:
            M[M[A]] = M[i]
        else:
            M[j] = M[i]

        # Memory Mapped ALU
        M[Add]  = M[A] + M[B]
        M[Sub]  = M[A] - M[B]
        M[Mult] = M[A] * M[B]
        M[Div]  = 0 if M[B] == 0 else M[A] // M[B]

        M[Equal]   = int(M[A] == M[B])
        M[Greater] = int(M[A] > M[B])
        M[Lesser]  = int(M[A] < M[B])

    return M

def tokenize(forth_code):
    tokens = []
    lines = forth_code.split('\n')
    for line in lines:
        # Remove comments starting with `\` or `(`
        line = line.split('\\')[0]
        if '(' in line:
            # Remove comments within parentheses
            while '(' in line:
                start = line.find('(')
                end = line.find(')', start)
                if end == -1:
                    # Handle error: unmatched parenthesis
                    raise SyntaxError("Unmatched '(' in line: " + line)
                line = line[:start] + line[end+1:]
        tokens.extend(line.strip().split())
    return tokens

def compile_forth(forth_code, M, memory_pointer):
    tokens = tokenize(forth_code)
    program = []
    index = 0
    stack = []
    labels = {}
    user_words = {}
    call_stack = []

    def compile_literal(token):
        value = int(token)
        return [value, D['L'], D['L'], D['S']]

    builtin_words = {
        '+': [D['+'], D['W']],
        '-': [D['-'], D['W']],
        '*': [D['*'], D['W']],
        '/': [D['/'], D['W']],
        'DUP': [D['Dup'], D['W']],
        'SWAP': [D['Swap'], D['W']],
        'DROP': [D['Drop'], D['W']],
        'OVER': [D['Over'], D['W']],
        'ROT': [D['Rot'], D['W']],
        'NOT': [D['Not'], D['W']],
        'NEGATE': [D['Negate'], D['W']],
        'SQUARE': [D['Square'], D['W']],
        'CUBE': [D['Cube'], D['W']],
        'FOURTH': [D['Fourth'], D['W']],
        'DOUBLE': [D['Double'], D['W']],
        '--': [D['--'], D['W']],
        '++': [D['++'], D['W']],
        '==': [D['=='], D['W']],
        '>': [D['>'], D['W']],
        '<': [D['<'], D['W']],
        '!=': [D['!='], D['W']],
        'MOD': [D['Mod'], D['W']],
        'HALVE': [D['Halve'], D['W']],
        # Add more built-in words as needed
    }

    while index < len(tokens):
        token = tokens[index].upper()
        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):
            program.extend(compile_literal(token))
            index += 1
        elif token in builtin_words:
            program.extend(builtin_words[token])
            index += 1
        elif token == 'IF':
            # Evaluate condition (already on stack)
            # Generate code for branch if false
            branch_address = len(program)
            program.extend([D['If'], D['W'], 0])  # Placeholder for address
            stack.append(('IF', branch_address))
            index +=1
        elif token == 'ELSE':
            # Generate jump over the else-part
            jump_address = len(program)
            program.extend([D['Branch'], D['W'], 0])  # Placeholder for address
            # Fix the previous IF's branch address
            if_label = stack.pop()
            if if_label[0] != 'IF':
                raise SyntaxError("ELSE without matching IF")
            program[if_label[1] + 2] = len(program)  # Fix branch address
            stack.append(('ELSE', jump_address))
            index +=1
        elif token == 'THEN':
            # Fix unresolved addresses
            label = stack.pop()
            if label[0] == 'IF' or label[0] == 'ELSE':
                program[label[1] + 2] = len(program)
            else:
                raise SyntaxError("THEN without matching IF or ELSE")
            index +=1
        elif token == 'BEGIN':
            begin_address = len(program)
            stack.append(('BEGIN', begin_address))
            index +=1
        elif token == 'UNTIL':
            # Evaluate condition (already on stack)
            # Generate code to branch if false back to BEGIN
            begin_label = stack.pop()
            if begin_label[0] != 'BEGIN':
                raise SyntaxError("UNTIL without matching BEGIN")
            program.extend([D['If'], D['W'], begin_label[1]])
            index +=1
        elif token == 'DO':
            # Push loop indices onto the stack
            # Record the start address
            do_address = len(program)
            stack.append(('DO', do_address))
            index +=1
        elif token == 'LOOP':
            # Decrement loop index and branch if not zero
            do_label = stack.pop()
            if do_label[0] != 'DO':
                raise SyntaxError("LOOP without matching DO")
            # Generate code for the loop
            program.extend([D['Loop'], D['W'], do_label[1]])
            index +=1
        elif token == ':':
            # Begin a new word definition
            word_name = tokens[index + 1].upper()
            index += 2  # Skip ':' and word name
            word_tokens = []
            while tokens[index].upper() != ';':
                word_tokens.append(tokens[index])
                index += 1
            # Compile word tokens
            word_program, memory_pointer = compile_forth(' '.join(word_tokens), M, memory_pointer)
            # Store compiled word in memory M
            word_length = len(word_program)
            M[memory_pointer:memory_pointer + word_length] = word_program
            D[word_name] = memory_pointer  # Update dictionary with new word
            memory_pointer += word_length
            index += 1  # Skip ';'
        elif token in D:
            # It's a user-defined word or predefined word
            program.extend([D[token], D['W']])
            index +=1
        elif token == ';':
            # Skip semicolons outside word definitions
            index +=1
        else:
            raise ValueError(f"Unknown token: {token}")

    # Append Halt instruction at the end
    program.extend([0, D['L'], D['L'], D['IP']])  # Halt

    return program, memory_pointer

# Now, let's test the compiler with some Forth code

def test_compiler():
    forth_program = """
    : SQUARE DUP * ;
    : CUBE DUP SQUARE * ;
    5 SQUARE
    3 CUBE
    """
    M = setup(forth_program)
    M = run(M)
    answer = M[D['SL']+1:D['SL']+1+M[D['SL']]]
    print("Stack after execution:", answer.tolist())

# Run the test
test_compiler()

